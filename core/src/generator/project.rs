use std::{
    env::current_dir,
    fs::{create_dir_all, File},
    io::Write,
};

use cargo_toml::Manifest;
use crate::Context;

#[derive(Debug, Copy, Clone)]
/// Logger struct used for Display in the ligen crates
pub struct ProjectGenerator {}

impl ProjectGenerator {
    /// generate function for the ProjectGenerator
    pub fn generate(context: &Context) {
        let manifest_path = &context.arguments.manifest_path;
        let manifest_dir  = manifest_path.parent().expect("Couldn't get manifest directory.");
        let target_dir    = &context.arguments.target_dir;
        let manifest      = Manifest::from_path(manifest_path).expect("Failed to parse Cargo.toml");

        let generator_version = env!("CARGO_PKG_VERSION");

        // FIXME: This is broken when manifest is a workspace.
        let package = manifest.package.expect("Couldn't get package.");
        let name = package.name;

        let crate_path = target_dir.join("ligen").join(&name);

        let include_path = crate_path.join("include");
        let lib_path = crate_path.join("lib");
        let cmake_path = crate_path.join("CMakeLists.txt");
        create_dir_all(include_path).expect("Failed to create include directory");
        create_dir_all(lib_path).expect("Failed to create lib directory");
        let mut file = File::create(&cmake_path).expect(&format!("Failed to create {}", cmake_path.display()));

        let cmake_content = format!(
            "# Auto-generated by ligen-c {}

CMAKE_MINIMUM_REQUIRED(VERSION 3.0)
PROJECT(\"{}\")

IF(TARGET ${{PROJECT_NAME}})
RETURN()
ENDIF()

# INTERFACE is used to create a header-only library.
ADD_LIBRARY(${{PROJECT_NAME}} INTERFACE)
TARGET_INCLUDE_DIRECTORIES(${{PROJECT_NAME}} INTERFACE include)
TARGET_LINK_LIBRARIES(${{PROJECT_NAME}} INTERFACE ${{CMAKE_SOURCE_DIR}}/lib/${{PROJECT_NAME}}.lib)",
            generator_version, &name
        );

        file.write_all(cmake_content.as_bytes())
            .expect("Failed to write file");
    }
}
